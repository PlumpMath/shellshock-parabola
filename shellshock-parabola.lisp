;;;; shellshock-parabola.lisp

(in-package #:shellshock-parabola)

;;; "shellshock-parabola" goes here. Hacks and glory await!

(defvar *blending-params* (make-blending-params) "Cepl blending object")
(defvar *quad* nil "Opengl quad points")
(defvar *quad-stream* nil "CEPL stream of *quad*")
(defparameter *radius-pixels* 304 "Constant for converting btwn pixels and in-game distances (width of 35,45 shot from height of barrel)")
(defparameter *identity-height-pixels* 94 "Height of shot from *radius-pixels")
(defparameter *running* nil "Is the main loop running?")
(defparameter *last-time* (get-internal-real-time) "Internal time of last render.")
(defparameter *size* #(2000 2000) "Initial size")
(defparameter *max-size* #(2000 2000) "Window creation size (to account for resize bug, see *transform*)")
(defparameter *tank-pos* (v! 0 0) "Opengl position of the tank")
(defparameter *power* 35 "Current power")
(defparameter *angle* 45 "Current angle")
(defparameter *one-second* 0.0 "Counts up every second for extra one-sec refresh.")
(defparameter *left* t)
(defparameter *barrel-length* 0.026 "Barrel size constant (probably could be derived from other constants)")
(defparameter *transform* (m4:* (m4:scale (v! (/ (x *size*) (x *max-size*))
                                              (/ (y *size*) (y *max-size*))
                                              1))
                                (m4:translation (v! (/ (- (x *max-size*)
                                                          (x *size*))
                                                       2 (x *max-size*))
                                                    (/ (- (y *max-size*)
                                                          (y *size*))
                                                       2 (x *max-size*))
                                                    0)))
  "Transform of everything drawn to only make use of visible part of opengl viewport.")
(defun calc-transform (size)
  (setf *transform* (m4:* (m4:translation (v! (/ (- (x *max-size*)
                                                    (x size))
                                                 -1 (x *max-size*))
                                              (/ (- (y *max-size*)
                                                    (y size))
                                                 -1 (y *max-size*))
                                              0))
                          (m4:scale (v! (/ (x size) (x *max-size*))
                                        (/ (y size) (y *max-size*))
                                        1)))))

(defun round-to (n &optional (place 0) (func #'round))
  (if (not (= place 0))
      (let ((exp (expt 10 place)))
        (float (/ (funcall func (* n exp)) exp)))
      (funcall func n)))

(defun-g vert ((quad g-pt) &uniform (transform :mat4))
  (values (* transform (v! (pos quad) 1))
          (s~ (pos quad) :xy)))
(defun-g main-curve-frag ((pos-2d :vec2) &uniform (a :float) (h :float) (k :float) (color :vec3))
  (cond ((< (abs (- (x pos-2d)
                    (+ h (sqrt (/ (- (y pos-2d) k) a)))))
            0.005)
         (v! color 1.0))
        ((< (abs (- (x pos-2d)
                    (- h (sqrt (/ (- (y pos-2d) k) a)))))
            0.005)
         (v! color 1.0))
        (t (v! 0.5 0.5 0.5 0.0))))
(defun-g main-curve-frag-left ((pos-2d :vec2) &uniform (a :float) (h :float) (k :float) (color :vec3))
  (cond ((< (abs (- (x pos-2d)
                    (- h (sqrt (/ (- (y pos-2d) k) a)))))
            0.005)
         (v! color 1.0))
        (t (v! 0.5 0.5 0.5 0.0))))
(defun-g main-curve-frag-right ((pos-2d :vec2) &uniform (a :float) (h :float) (k :float) (color :vec3))
  (cond ((< (abs (- (x pos-2d)
                    (+ h (sqrt (/ (- (y pos-2d) k) a)))))
            0.005)
         (v! color 1.0))
        (t (v! 0.5 0.5 0.5 0.0))))

(defun-g dot-frag ((pos-2d :vec2) &uniform (pos :vec2) (color :vec3))
  (if (< (sqrt (+ (pow (- (y pos-2d) (y pos)) 2)
                  (pow (- (x pos-2d) (x pos)) 2)))
         0.01)
      (v! color 1.0)
      (v! 0.0 0.0 0.0 0.0)))

(def-g-> prog-1 ()
  #'vert #'main-curve-frag)
(def-g-> prog-1-left ()
  #'vert #'main-curve-frag-left)
(def-g-> prog-1-right ()
  #'vert #'main-curve-frag-right)
(def-g-> prog-dot ()
  #'vert #'dot-frag)

(defun step-demo ()
  (let ((now (get-internal-real-time)))
    (if (< (- now *last-time*) 1000/60)
        (sleep (/ (- 1000/60 (- now *last-time*)) 1000)))
    (incf *one-second* 1000/60)
    (setf *last-time* now)
    (if (> *one-second* 1000)
        (progn
          (update-interface :silently t)
          (setf *one-second* 0))))
  (step-host))

(defun run-loop ()
  (setf *running* t)
  (setf *quad* (make-gpu-array
                (list (list (v! -1.0   1.0 0 0) (v!  0.0   1.0))
                      (list (v! -1.0  -1.0 0 0) (v!  0.0   0.0))
                      (list (v!  1.0  -1.0 0 0) (v!  1.0   0.0))
                      (list (v! -1.0   1.0 0 0) (v!  0.0   1.0))
                      (list (v!  1.0  -1.0 0 0) (v!  1.0   0.0))
                      (list (v!  1.0   1.0 0 0) (v!  1.0   1.0)))
                :element-type 'g-pt
                :dimensions 6))
  (setf *quad-stream* (make-buffer-stream *quad* :retain-arrays t))
  (setf *last-time* (get-internal-real-time))
  (gl:depth-func :lequal)
  (skitter:whilst-listening-to
      ((#'window-size-callback (skitter:window 0) :size)
       (#'mouse-callback (skitter:mouse 0) :button)
       (#'mouse-callback (skitter:mouse 0) :pos)
       (#'key-callback (skitter:keyboard 0) :button))
    (loop :while (and *running* (not (shutting-down-p))) :do
      (continuable (step-demo)
        (livesupport:update-repl-link)))))

(defun stop-loop ()
  (setf *running* nil))

;;--------------------------------------------------------------
;; controls

(defun mouse-callback (event timestamp)
  (declare (ignore event timestamp))
  (when (skitter:mouse-down-p skitter.sdl2.mouse-buttons:mouse.left)
    (setf *tank-pos* (let ((arr (skitter:xy-pos-vec (skitter:mouse-pos (skitter:mouse 0)))))
                       (v! (* 1.01 (- (* 2 (/ (x arr)
                                              (x *size*))) 1))
                           (* 1.01 (+ (* -2 (/ (y arr)
                                               (y *size*))) 1)))))
    (update-interface :silently t)))

(defun key-callback (event timestamp)
  (declare (ignore timestamp))
  (when (slot-value event 'skitter::down-p)
    (let ((key (slot-value event 'skitter::container-index))
          (amm (+ (if (skitter:key-down-p skitter.sdl2.keys:key.lctrl)
                      1
                      0)
                  (if (skitter:key-down-p skitter.sdl2.keys:key.lshift)
                      1
                      0)
                  1)))
      (cond
        ((= key skitter.sdl2.keys:key.up) (setf *power* (min (+ *power* amm) 100)))
        ((= key skitter.sdl2.keys:key.down) (setf *power* (max (- *power* amm) 0)))
        ((= key skitter.sdl2.keys:key.left) (setf *angle* (min (+ *angle* amm) 180)))
        ((= key skitter.sdl2.keys:key.right) (setf *angle* (max (- *angle* amm) 0))))
      (update-interface))))

;;--------------------------------------------------------------
;; window

(defun radians->degrees (r)
  (* 180 (/ r pi)))
(defun degrees->radians (d)
  (/ (* d pi) 180))
(defun round-radians-as-degrees (r)
  (let ((deg (radians->degrees r)))
    (degrees->radians (round deg))))

(defun dist-height->power-angle (d h)
  (let* ((angle (atan (/ (* 4 h) d)))
         (low-power (* 35 (sqrt (/ d
                                   (sin (* 2 angle)) *radius-pixels*)))))
    (values low-power angle)))

(defun pixel->gl (x max)
  (1- (* 2 (/ x max))))

(defun update-interface (&key (silently nil))
  (declare (optimize (debug 3)))
  (when (not silently)
    (print *size*)
    (terpri)
    (format t "~a, ~a" *power* (if (> *angle* 90)
                                   (abs (- *angle* 180))
                                   *angle*)))
  (with-blending *blending-params*
    (clear)
    (let* ((dist (+ 0.001 (* *radius-pixels* (expt (/ *power* 35) 2) (sin (* 2 (degrees->radians *angle*))))))
           (height (+ 0.001 (* (tan (degrees->radians *angle*)) dist 1/4)))
           (tankx (+ (x *tank-pos*) (* *barrel-length* (/ (x *max-size*) (x *size*)) (cos (degrees->radians *angle*)))))
           (tanky (+ (y *tank-pos*) (* *barrel-length* (/ (y *max-size*) (y *size*)) (sin (degrees->radians *angle*)))))
           (h (+ tankx (/ dist (x *size*))))
           (k (+ tanky (* 2 (/ height (y *size*)))))
           (a (/ (- tanky k)
                 (expt (- tankx h) 2))))
      (map-g #'prog-1 *quad-stream* :color (v! 0.0 0.0 1.0) :transform (calc-transform *size*)
                                    :a a
                                    :h h
                                    :k k)
      (map-g #'prog-dot *quad-stream* :color (v! 1.0 0.0 0.0) :transform (calc-transform *size*) :pos (v! tankx tanky))
      )
    (map-g #'prog-dot *quad-stream* :color (v! 0.0 1.0 0.0) :transform (calc-transform *size*) :pos *tank-pos*)
    (swap)))

(defun window-size-callback (event timestamp)
  (declare (ignore timestamp))
  (setf *size* (skitter:size-2d-vec event))
  (update-interface))
